				Micro Services Implementation Using Vertx
..............................................................................................

Application Types

1.System softwares- OS,Device related application
2.Application softwares- to solve real world problems - banking,insurance,retail...

How to develop application software?

-Programming language - java
   -Lib,Frameworks,toolkits

Any application has two things

-Application code

-Datasource-Database/filesystem/inmemory.

Any application is designed based on some arch.

-main frame based
-client server 
  -single
  -two tier
  -there tier
  -n-tier
tier -layer

-User interface
-back end 
   -service 
   -data layer

Banking:
 -java language- Spring Framework

Web application-Restfull architecture-based on Rest spec.

-Spring MVC
.........................................................................................
                                           Distributed Application
..........................................................................................

1.Monolithic

Apps in java :

 in dev we write code,compile code,run time.

how to handover application to customer - packing

 java apps are packed
   -jar
   -war
   -ear

data.jar
util.jar
banking.war

...........................................................................................

Deployment procesS:

  putting war/ear on web servers
...........................................................................................

Customers/users will access the application using urls -http://www.examplebank.com/

..........................................................................................


1.Monollithic Application Development Steps

Properties:

1.Domain - Biz requirement  - Domain Analyist - Collecting Requirement

2.Requirement into Software Specification

Technology:
 Java-JEE

 -Framework -Spring
 -Database - MYsql
 -Middlewares -  RabbitMQ....
 -Dev Server -Tomcat
 -DeploymentServer - JBoss  

3.High Level Design
   Data Modeling
   JEE App Design
    -Web layer ,entity layer,messaging layer


4.Development
    Provisions for dev

5.Testing 
    

6.Production Plan.


Monolithic app work flow will go one by one 


Cons of Monolithic:

1.Requirement can t be freezed in short duration, since biz is dynamic.

2.Tech stack:
  There are many modules in the app, any one of the module need to be development in different
 Technology
  -python,nodejs,Ruby,C#
  -different databases -  sql, nosql,messaging servers

 Vendor-lock

3.Design can be started once req is freezed
  -we have many modules, most of the modules are over, payment module taking much time to freeze.

4.Dev
   Dev cant be started due to req not clear.

5.Test 
   until over testing cant be

6.Deployment - Production
   -The whole app must be ready for deployment.
   -Provisioning
      -database,webservers,middlewares....
..............................................................................................
					Micro Services:

Common ideas

1.Highly maintainable and testable
2.Loosely coupled
3.Independently deployable
4.Organized around business capabilities
5.Owned by a small team


Advantages:

Strong Module Boundaries: Microservices reinforce modular structure, which is particularly
important for larger teams.

• Independent Deployment: Simple services are easier to deploy, and since they are autonomous,
are less likely to cause system failures when they go wrong.

• Technology Diversity: You can mix multiple languages, development frameworks and datastorage
technologies (i.e. each team working on a microservice has more flexibility to employ
different technologies without affecting other teams).
  

Cons of Micro Services:
.......................

• Distribution: Distributed systems are harder to program since remote calls are slow and are
always at risk of failure.
• Eventual Consistency: Maintaining strong consistency is extremely difficult for a distributed system, which means everyone has to manage eventual consistency.
• Operational Complexity: You need a mature operations team to manage lots of services which
are being redeployed regularly.
.............................................................................................

.............................................................................................
                               Distributed Application Design Patterns
.............................................................................................

Distributed Application Design Pattern: 
-Monolithic
-MicroServices
.............................................................................................
                            Monoloith Design patterns 
.............................................................................................

1.GOF patterns
2.JEE Patterns
   -MVC
   -DAO
   -Service Locator

..............................................................................................
	        Microservices Application Design Patterns
.............................................................................................
Monolith to Micro services:
...........................
Cube Model to scale app

-Functional Decomposition : DDD model- 
   Microservices are subdomain driven model. 


Data Layer-(Data Management) Design patterns In Microservices:
............................................
1.Database per Service
2.Shared database
3.Saga
4.API Composition
5.CQRS
6.Domain event
7.Event sourcing
...........................................................................................  

		Application Development and its Related Patterns:
...........................................................................................

-Language ----Framework /Lib
-Java:
Style:
  -Object Oriented Programming language
  -Functional Style Programming 

OOP :
 -Object
   -State + Behaviour

What is Service?
  Service is nothing but "offer".
  The Object which offer some features

  OrderService offers order related Features
  -placeOrder
  -findAllOrders
  -findOrderByid
  -updateExistingOrder
  -cancelOrder
  -etc....
What is Micro?
   Smallest 

What is Micro Service?
   Smallest Service in   a domain

Is there is any pattern is avaible to design Service?

Based on SOLID Prinicples

1.Single Responsibility Principle
2.Open/Closed Principle
3.Liskov Substitution Principle
4.Interface Segregation Principle
5.Dependency Inversion

Every service need to designed based on 

 "Single Responsibility Principle" - SRP

How to Represent Service?

 Every Service is Object.

class CreditCardService {

}
class DebitCardService {

}
............................................................................................
				Object (Service) Communication:
.............................................................................................
Service Communication style Design Pattern

1.Remote Procedure Invocation
2.Messaging
3.Domain-specific protocol
4.Idempotent Consumer
...........................................................................................
				Service Communication and failures

Distributed Services are subject to fail,slow.

Eg:

 Service-A calls Service-B --may call external systems like db,apis,message middlewares.

Service-B may fail due to various reasons
   -Network failure
   -Latancy issues
   -Exceptions and Errors

Because of One Service Failure
The entire system should not fail.
..............................................................................................
                           Micro Service Design pattern to handle failures
			           (Realiability Patterns)
.............................................................................................

Incase failure happens, Reality Patterns gives alternate solution to the caller(clients).

1.CircuitBreaker
2.BulkHead
3.ReateLimiter
4.Retry
5.TimeLimiter
6.Fallbacks using cache
..............................................................................................
				   Service Identification and Communication
..............................................................................................
				
If services are talking each other in network we need to know

-location of the service and port address of the service.

incase if services are running containers and cloud env, where ip address is dynamic, how services can collabrate using ip address/dns names.
.............................................................................................
			      Service Registry and Discovery Patterns
...............................................................................................

What is Service Registry?
   
   Middleware where services are registered before access them.  

Service Registries are third party softwares

1.Apache Zookeeper
2.Consul
3.Netflix eureka
4.Redis
etc......

Why Service Registry?

-Where are services are hosted in dynamic virtualized or containerized env where we cant identify the service instances.

What is Discovery ? 
  Looking up/Search services from Service Registry
............................................................................................
  		          Scalability and High Availablity
............................................................................................

What if i want to run the same instance multiple copies?
 This is called horizintal scaling 

When we scale apps, we need to indentifiy which instance will be served to the caller service.

Load Balancer  is component which takes cares of selecting right instance based on algorthims provided by load balancer.

Algorthims may be round robin,random,cpu usage based,sharding , latency based.
..............................................................................................
			     How to deploy microservices in production
				     Deployment Patterns
..............................................................................................

1.Multiple services per host.
2.Single Service instance per host
3.Service instance per vm
4.Service instance per container
5.Servless Deployment
6.Service Deployment Platforms
..............................................................................................
				 Development and Production Common things

1.Configuration:
   How to configure application properties
   -Settings
      db
      web
      security
      app dynamic parameters

We can maintain externalized / distribtued configuration system - Centeralized Configuration
information
 -database
 -mailing
 -registry
 -payment gate
 -passwords/ walets

It can a server.
 -ldap
 -kubernets - config map
 -apache zookeeper

What ever key value server.
.............................................................................................
				Maintaince/Management patterns
............................................................................................
Monitoring /Managing Patterns:
..............................

1.Logging
  Logs with in Services

Log Types:
-Console Logs
-File Based logs
-Database logs

				How to log centeralized and anaylis

1.ELK
2.Graylog
3.EFK
4.Sys logs
..............................................................................................
					Mertics

Perfomance Management:

How to measure microservices performance?

Memory,Process,threads....

1.Prometheus
2.DataDog
3.MicroMeter
..............................................................................................
				  Tracing
		
How to trace service calls?
 service to service call duration,response time.

1.Zipkin
2.Jaeger
.............................................................................................
				Health Patterns and Tools
............................................................................................

Health of
-database
-web end points
-message server health

1.Prometheus
2.actuator 
..............................................................................................
				 External API GateWay

Api Gate way can be used for connecting microservices in and outside world.

Api gateways

1.apigee way
2.aws
3.Netfilx api gateway
4.Nginx
.............................................................................................
			          Micro Services Security
............................................................................................

Authentication and authorization

In micro servies and gateways patterns, microservices consist of numerous services.
The api gate way is the single entry point for client request.
It authenticate requests, and forwards them to other services, which might in turn invoke other services

In monlith systems, auth implemented via "Session Tokens" -  userid and password is exchanged
via "cookie" header.
............................................................................................
				Implementation : JSON Web Token
............................................................................................

JWT is also token based pattern like "session Tokens" , where session tokens are very usefull only if the application is hosted in single server.

Since session token cant be used to track apps running in different process. so we can use 
JWT , Sticky Session from api gateway.
.............................................................................................
   		 Micro Service Pattern/Architecture Implementation
............................................................................................

Microservies can be implemented on any platform(os), on language - Platform,language indepand.

Micro service implmentions On JVM:
..................................

1.Spring Framework provides an Project - Spring Cloud
2.Quarkus Framework provides an project - MicroProfile ---SmallRye
3.Ecplise Vertx
4.MicroNaut - written in Kotlin
5.Light4J
etc.......
..............................................................................................

                           MicroServices implemenation on Vertx
.............................................................................................

What is service?
  Object which gives api, which transfer data.

Service Implemenation:
-Verticles

Types of Services:

-HTTP based service
   Which are exposed as Restful api
-BackEnd service
   Within Vertx echo system using EventBus

.............................................................................................
				Restfull Web Developement in vertx
.............................................................................................


Core features of vertx web development

-it is non blocking - min number of threads are used- there is no request per thread model.
-it is reactive, so that data streaming ,processing is possible.

Web App development in vertx:

Vertx is fully powered with non blocking apis.
Vertx supports http prototcal to build non blocking web apps.

Modules In web space:

1.vertx core http module.
2.vertx-web module - It is minialistic framework to build realtime Webservices and dynamic web apps
3.vertx-webclient -  Service interaction api via  http Protocal


HTTP Core module Object:

1.HttpServer
   -Used to build web containers
   -Used to handle incomming request and sending response.
2.HttpServerRequest
   -Object used to handle incoming request
   -has api called response() to get Resonse Object
3.HttpServerResponse
   -Object used to send resonse to clients



Simple Http Server:
package com.cts.vertx.microservice;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpServer;
import io.vertx.core.http.HttpServerResponse;

public class MainVerticle extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    //create WebServer
    HttpServer httpServer = vertx.createHttpServer();
    //Handle Client Request : on event loop thread
    httpServer.requestHandler(request -> {
      //how to send response
      HttpServerResponse response = request.response();
      //set status code
      response.setStatusCode(200);
      //set content type
      response.putHeader("content-type", "text/plain");
      //set custom header
      response.putHeader("greeting", "Hello");
      //content length header
      response.putHeader("Content-Length", "100");
      //write data into output stream
      response.write("Hello");
      //close the connection
      response.end();
    });

    //Start Server
    httpServer.listen(8080, ar -> {
      if (ar.succeeded()) {
        System.out.println("HTTP Server started on " + ar.result().actualPort());
      }
    });

  }
}
......................................................................................	
				   Are you fluent?
.......................................................................................

Fluent is other wise called as builder pattern or command chain pattern.

A fluent api where multiple methods can be chained together. : which is mostly recommended in vertx.


package com.cts.vertx.microservice;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;

public class MainHttpServerVerticle extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    //Fluent Api pattern
    vertx.createHttpServer().requestHandler(req -> {
      req.response()
        .putHeader("content-type", "text/plain")
        .putHeader("message", "Hello")
        .end("Hello");
    }).listen(8080, ar -> {
      if (ar.succeeded()) {
        System.out.println("HTTP Server started on " + ar.result().actualPort());
      }
    });

  }
}
...........................................................................................
			     JSON DATA
...........................................................................................

In Vertx json is default data interchange format for sending data across the micro services.

Vertx Provides Builtin json parser Object.

JsonObject

How to create json object and send it to client?

package com.cts.vertx.microservice;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;


public class JsonHttpVerticle extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {

    //old style
//    JsonObject jsonObject = new JsonObject();
//    jsonObject .put("id", 1);
//    jsonObject .put("name", "Subramanian");
//    jsonObject  .put("city", "coimbatore");

    //fluent style
//    JsonObject user = new JsonObject()
//      .put("id", 1)
//      .put("name", "Subramanian")
//      .put("city", "coimbatore");

    //Map object can be converted into json
//    Map<String, Object> map = new HashMap<>();
//    map.put("id", 1);
//    map.put("name", "Subramanian");
//    map.put("city", "coimbatore");
//    JsonObject user = new JsonObject(map);

    User userModel = new User(1, "Subramanian", "Coimbatore");
    JsonObject user = new JsonObject()
      .put("id", userModel.getId())
      .put("name", userModel.getName())
      .put("city", userModel.getCity());

    //return list of users:JsonArray
    JsonArray users = new JsonArray()
      .add(user)
      .add(new JsonObject().put("id", 2).put("name", "Ram").put("city", "Coimbatore"));

    //Fluent Api pattern
    vertx.createHttpServer().requestHandler(req -> {
      req.response()
        .putHeader("content-type", "application/json")
        .putHeader("message", "Hello")
        .end(users.encodePrettily());
    }).listen(8080, ar -> {
      if (ar.succeeded()) {
        System.out.println("HTTP Server started on " + ar.result().actualPort());
      }
    });

  }
}
.............................................................................................
			   How to Handle Client Request
.............................................................................................

Simple Request Handling:

package com.cts.vertx.microservice;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;

public class HttpClientRequestHandling extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    //Fluent Api pattern
    vertx.createHttpServer().requestHandler(req -> {
      //how to read incoming request data
      req.bodyHandler(bodyHandler -> {
        System.out.println(bodyHandler.toString());
      });
      req.response()
        .putHeader("content-type", "text/plain")
        .putHeader("message", "Hello")
        .end("Hello");

    }).listen(8080, ar -> {
      if (ar.succeeded()) {
        System.out.println("HTTP Server started on " + ar.result().actualPort());
      }
    });
  }
}


Echo : Receive input and return the same.

package com.cts.vertx.microservice;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;

public class HttpClientRequestHandling extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    //Fluent Api pattern
    vertx.createHttpServer().requestHandler(req -> {
      //how to read incoming request data
//      req.bodyHandler(bodyHandler -> {
//        System.out.println(bodyHandler.toString());
//        req.response()
//          .putHeader("content-type", "text/plain")
//          .putHeader("message", "Hello")
//          .end(bodyHandler.toString());
//      });

      //how to read json
      req.bodyHandler(bodyHandler -> {
        JsonObject jsonObject = bodyHandler.toJsonObject();
        System.out.println(jsonObject.encodePrettily());
        //Map with user
//        User user = jsonObject.mapTo(User.class);
//        System.out.println(user);
        req.response()
          .putHeader("content-type", "text/plain")
          .putHeader("message", "Hello")
          .setStatusCode(201)
          .end("Created");
      });


    }).listen(8080, ar -> {
      if (ar.succeeded()) {
        System.out.println("HTTP Server started on " + ar.result().actualPort());
      }
    });
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////
			   Are we building Realtime RESTFull Services
..............................................................................................
No!

Because RestFull webservies must have the following features

1.Resource - like CustomerResource,OrderResource,ProductResource.....


2.URI Mapping

 /api/customers
 /api/customers/1
 /api/customers/orders
 /api/customers/search/name

3.HTTP Method Mapping
  GET,POST,DELETE,PUT

Vertx-core http module cant be used to build realtime http based microservices
............................................................................................
				vertx-web

Vertx-web has been built on the top of vertx-core http module like servlets are core spring-mvc is framework

Vertx-web is mini framework built on the top of vertx-core http

Features:
Routing (based on method, path, etc)
Regular expression pattern matching for paths
Extraction of parameters from paths
Content negotiation
Request body handling
Body size limits
Multipart forms
Multipart file uploads
Sub routers
Session support - both local (for sticky sesions) and clustered (for non sticky)
CORS (Cross Origin Resource Sharing) support
Error page handler
HTTP Basic/Digest Authentication
Redirect based authentication
Authorization handlers
JWT/OAuth2 based authorization
User/role/permission authorization
Favicon handling
Template support for server side rendering, including support for the following template engines out of the box:
Handlebars
Jade,
MVEL
Thymeleaf
Apache FreeMarker
Pebble

Rocker

Response time handler

Static file serving, including caching logic and directory listing.

Request timeout support

SockJS support

Event-bus bridge

CSRF Cross Site Request Forgery

VirtualHost
..............................................................................................
 
Simple Rest:
package com.cts.vertx.microservice.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.ext.web.Router;

public class SimpleRest extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    //create Router object
    Router router = Router.router(vertx);

    //expose api
    router.get("/api/products").handler(rc -> {
      rc.response().end("findAll products");
    });
    router.get("/api/products/:productId").handler(rc -> {
      rc.response().end("Get Product By Id");
    });
    router.post("/api/products").handler(rc -> {
      rc.response().end("Product Saved");
    });
    router.put("/api/products/:productId").handler(rc -> {
      rc.response().end("update Product By Id");
    });
    router.delete("/api/products/:productId").handler(rc -> {
      rc.response().end("delete Product By Id");
    });

    vertx.createHttpServer().requestHandler(router).listen(8080, ar -> System.out.println(
      "Server is Runnin in " + ar.result().actualPort()
    ));

  }
}
..............................................................................................
					InMemory CURD
.....................................................................................................................

package com.cts.vertx.microservice.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

import java.util.HashMap;
import java.util.Map;

public class RestInMemoryCurdVerticle extends AbstractVerticle {

  //in memeory db
  private Map<String, JsonObject> products = new HashMap<>();

  @Override
  public void start() throws Exception {
    setupIntialData();
    //create Router object
    Router router = Router.router(vertx);

    //expose api

    //This handler is called for every request and every url
    //middlewares/filters/interceptors
    router.route().handler(rc -> {
      System.out.println(rc.request().method() + " - " + rc.request().path());
      rc.next();
    });
    //Middleware for this url
    router.route(HttpMethod.GET, "/api/products").handler(rc -> {
      System.out.println("Products api called");
      rc.next();
    });
    //handling Body payloads : Middlewares
    router.route().handler(BodyHandler.create());

    router.get("/api/products").handler(rc -> {
      JsonArray arr = new JsonArray();
      products.forEach((k, v) -> arr.add(v));
      rc.response().putHeader("content-type", "application/json").end(arr.encodePrettily());
    });
    router.get("/api/products/:productId").handler(rc -> {
      String productId = rc.request().getParam("productId");
      HttpServerResponse response = rc.response();
      //if product id is null
      if (productId == null) {
        sendError(400, response);
      } else {
        JsonObject product = products.get(productId);
        if (product == null) {
          sendError(400, response);
        } else {
          response.putHeader("content-type", "application/json").end(product.encodePrettily());
        }
      }

    });
    router.post("/api/products/:productId").handler(rc -> {
      String productId = rc.request().getParam("productId");
      HttpServerResponse response = rc.response();
      if (productId == null) {
        sendError(400, response);
      } else {
        JsonObject product = rc.getBodyAsJson();
        if (product == null) {
          sendError(400, response);
        } else {
          //add a new product
          products.put(productId, product);
          response.setStatusCode(201).end("Product is saved");
        }
      }
    });
    //todo--you have to implement update
    router.put("/api/products/:productId").handler(rc -> {
      rc.response().end("update Product By Id");
    });
    //todo--you have to implement update
    router.delete("/api/products/:productId").handler(rc -> {
      rc.response().end("delete Product By Id");
    });

    vertx.createHttpServer().requestHandler(router).listen(8080, ar -> System.out.println(
      "Server is Runnin in " + ar.result().actualPort()
    ));

  }

  private void sendError(int statuscode, HttpServerResponse response) {
    response.setStatusCode(statuscode).end();
  }

  private void setupIntialData() {
    addProduct(new JsonObject().put("id", "prod1234").put("name", "Tv").put("price", 10000));
    addProduct(new JsonObject().put("id", "prod1235").put("name", "watch").put("price", 234));
    addProduct(new JsonObject().put("id", "prod1236").put("name", "radio").put("price", 1000));
    addProduct(new JsonObject().put("id", "prod1237").put("name", "computer").put("price", 345));
    addProduct(new JsonObject().put("id", "prod1238").put("name", "tableandchair").put("price", 8999));

  }

  private void addProduct(JsonObject jsonObject) {
    products.put(jsonObject.getString("id"), jsonObject);
  }
}
.............................................................................................
			  How to integrate with databses
............................................................................................

In vertx web layer is non blocking, database layer can also be non blocking.

Vert only supports jdbc technology in non blocking way.
If i want to write jpa,hibernate, yes we can but which will be blocking way.

Non Blocking JDBC and Non blocking Web
......................................

Vert.x JDBC client:

This client allows you to interact with any JDBC compliant database using an asynchronous API from your Vert.x application.

The client API is represented with the interface 
JDBCClient
.

To use this project, add the following dependency to the dependencies section of your build descriptor:


SQL Client Templates
A small library designed to facilitate the execution and data manipulation of SQL queries

package com.cts.vertx.microservice.http.web;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.http.HttpMethod;
import io.vertx.core.http.HttpServerResponse;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;
import io.vertx.ext.web.handler.BodyHandler;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.sqlclient.Row;
import io.vertx.sqlclient.RowSet;
import io.vertx.sqlclient.SqlResult;
import io.vertx.sqlclient.templates.SqlTemplate;
import io.vertx.sqlclient.templates.TupleMapper;

import java.util.Arrays;
import java.util.Map;

public class RestJDBCService extends AbstractVerticle {

  //jdbc connection pool object
  private JDBCPool client;

  //SQL Template api
  private SqlTemplate<Map<String, Object>, RowSet<JsonObject>> getProductTemplate;
  private SqlTemplate<JsonObject, SqlResult<Void>> addProductTemplate;

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    //establish connection
    client = JDBCPool.pool(vertx, new JsonObject()
      .put("url", "jdbc:hsqldb:mem:test?shutdown=true")
      .put("dirver_class", "org.hsqldb.jdbcDriver"));

    //Test Connection
    client.getConnection().onSuccess(System.out::println).onFailure(System.out::println);

    //Getting Products
    String selectQuery = "SELECT id,name,price,weight FROM products WHERE id= #{id}";
    getProductTemplate = SqlTemplate.forQuery(client, selectQuery).mapTo(Row::toJson);

    //insert
    String insertQuery = "INSERT INTO  products(name,price,weight) VALUES (#{name},#{price},#{weight})";
    addProductTemplate = SqlTemplate.forUpdate(client, insertQuery).mapFrom(TupleMapper.jsonObject());

    //How to poulate some mock data
    String CRATE_TABLE = "CREATE TABLE IF NOT EXISTS products(id int IDENTITY, name VARCHAR(255), price FLOAT, weight INT)";

    client.query(CRATE_TABLE)
      .execute()
      .compose(res -> addProductTemplate.executeBatch(
        Arrays.asList(
          new JsonObject().put("name", "Tv").put("price", 10000).put("weight", 2),
          new JsonObject().put("name", "watch").put("price", 234).put("weight", 2),
          new JsonObject().put("name", "radio").put("price", 1000).put("weight", 2),
          new JsonObject().put("name", "computer").put("price", 345).put("weight", 2),
          new JsonObject().put("name", "tableandchair").put("price", 8999).put("weight", 2))))
      .compose(v -> {
        //After inserting data : start web part
        Router router = Router.router(vertx);
        //This handler is called for every request and every url
        //middlewares/filters/interceptors
        router.route().handler(rc -> {
          System.out.println(rc.request().method() + " - " + rc.request().path());
          rc.next();
        });
        //Middleware for this url
        router.route(HttpMethod.GET, "/api/products").handler(rc -> {
          System.out.println("Products api called");
          rc.next();
        });

        //handling Body payloads : Middlewares
        router.route().handler(BodyHandler.create());
        //Get all the products from the database
        router.get("/api/products").handler(this::handleGetProducts);
        router.post("/api/products").handler(this::handleAddProducts);

        return vertx.createHttpServer().requestHandler(router).listen(8080);

      }).<Void>mapEmpty().onComplete(startPromise);

  }

  private void handleAddProducts(RoutingContext rc) {
    HttpServerResponse response = rc.response();
    JsonObject product = rc.getBodyAsJson();
    addProductTemplate.execute(product)
      .onSuccess(res -> {
        response.setStatusCode(201).end("Created");
      }).onFailure(err -> {
        response.setStatusCode(500);
      });
  }

  private void handleGetProducts(RoutingContext rc) {
    HttpServerResponse response = rc.response();
    String selectProducts = "SELECT * From products";
    client.query(selectProducts)
      .execute(rowSet -> {
        if (rowSet.failed()) {
          rc.fail(500);
        } else {
          JsonArray arr = new JsonArray();
          rowSet.result().forEach(row -> {
            arr.add(row.toJson());
          });
          rc.response().putHeader("content-type", "application/json").end(arr.encodePrettily());
        }
      });


  }
}
.............................................................................................
				Service Communication : Micro services
.............................................................................................

Remote Procedure Invocation
Messaging
Domain-specific protocol
Idempotent Consumer
.............................................................................................
RPI : 
REST
gRPC
Apache Thrift
............................................................................................

REST
....
 The Services can talk each other via  http protocal.

How vertx implements HTTP communication?

Vert.x Web Client:
.................

Vert.x Web Client is an asynchronous HTTP and HTTP/2 client.

The Web Client makes easy to do HTTP request/response interactions with a web server, and provides advanced features like:


<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-web-client</artifactId>
 <version>4.1.2</version>
</dependency>

Provider:
package com.cts.vertx.microservice.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.ext.web.Router;

public class MessageServiceProvider extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    Router router = Router.router(vertx);
    //send plain message
    router.get("/message").handler(rc -> {
      rc.response().setStatusCode(200).end("Hello! Provider");
    });
    vertx.createHttpServer().requestHandler(router).listen(3000);
  }
}

Consumer
package com.cts.vertx.microservice.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.client.HttpResponse;
import io.vertx.ext.web.client.WebClient;


public class MessageServiceConsumer extends AbstractVerticle {

  private WebClient webClient;

  @Override
  public void start() throws Exception {
    Router router = Router.router(vertx);
    webClient = WebClient.create(vertx);
    //send plain message
    router.get("/hello").handler(rc -> {
      webClient.get(3000, "localhost", "/message")
        .send(ar -> {
          if (ar.succeeded()) {
            HttpResponse<Buffer> response = ar.result();
            rc.response().setStatusCode(200).end(response.bodyAsString());
          } else {
            rc.response().setStatusCode(500).end(ar.cause().getMessage());
          }
        });
    });

    vertx.createHttpServer().requestHandler(router).listen(3001);
  }

}

Deployer
package com.cts.vertx.microservice.communication;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;

public class Deployer extends AbstractVerticle {
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    vertx.deployVerticle(MessageServiceConsumer.class.getName(), ar -> {
      if (ar.succeeded()) {
        System.out.println(MessageServiceConsumer.class.getName() + " " + ar.result());
      } else {
        System.out.println(ar.cause());
      }
    });
    vertx.deployVerticle(MessageServiceProvider.class.getName(), ar -> {
      if (ar.succeeded()) {
        System.out.println(MessageServiceProvider.class.getName() + " " + ar.result());
      } else {
        System.out.println(ar.cause());
      }
    });
  }
}

Use Case:
You can build service , using service , you have to talk to external /third party rest apis



............................................................................................
				  Back End Services Communicaiton : EDA 
............................................................................................

EventBus:
  EventBus is used to enable service to service communication via events
..............................................................................................


1.message oriented style :Event Bus

Event Bus:

-Event Bus is nerve of vertx systems.

-Vertx By default is distributed

-Vertx carries distributed architecture by default

-In Vertx Verticles can communicate via Centraized Broker which is built in called event Bus.
-Event Bus uses tcp transport layer by default
-EventBus can send and recive data in the form of json and buffer


How verticle has been designed to adopt this architecture?

Verticle follows a design pattern  "Actor-like Model" ---->Actor Model design pattern


Event Bus:

1.Event Bus can allow verticles sends data from one place to another place
2.Event Bus forms a distributed peer-to-peer messaging system spannining multiple server nodes   and multiple browers.
3.Event bus allows sending messages in three ways
  1.pub/sub : one to many
  2.point-to-point : one to one
  3.request-reply(reponse) - one to one with acknowlegement.

4.Event bus identifies clients via "addressing"
   Messages are sent on the event bus to an "address"
   Address schemes can be any naming convention, recommendation is dns model "in.news.covid"
   
5.Handlers
   Since vertx is non blocking, messages are processed by handlers.
   You have to register a handler at an address

6.Type of Data
   Data type of message could be any primitive-int,char,boolean,String, Buffer,JSON

   Per Vertx Engine only One Event Bus-singleTon
..........................................................................................
			Event Bus : One to Many -  Pub-Sub Pattern
............................................................................................

Three Verticles:

1.HTTP verticle- which will send messages to other verticles - back end verticles

Front End Services and back end services.

package com.cts.vertx.microservice.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.ext.web.Router;

public class ApiGateWayService extends AbstractVerticle {
  public static final String MESSAGE_ADDRESS = "greeting.message";

  @Override
  public void start() throws Exception {
    super.start();
    Router router = Router.router(vertx);
    EventBus eventBus = vertx.eventBus();
    router.get("/api/greeter/:message").handler(rc -> {
      //Send to to event Bus
      String message = rc.request().getParam("message");
      //one to many : pub sub pattern
      eventBus.publish(MESSAGE_ADDRESS, message);
      rc.response().end("Message has been sent");
    });

    vertx.createHttpServer().requestHandler(router).listen(3000, ar -> {
      System.out.println("Server is Running @ " + ar.result().actualPort());
    });

  }
}

package com.cts.vertx.microservice.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;

public class GreeterService extends AbstractVerticle {
  public static final String MESSAGE_ADDRESS = "greeting.message";

  @Override
  public void start() throws Exception {
    super.start();
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(MESSAGE_ADDRESS);
    //list for message
    consumer.handler(message -> {
      System.out.println(GreeterService.class.getName() + "  -  " + message.body());
    });
  }
}

package com.cts.vertx.microservice.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;

public class HelloService extends AbstractVerticle {

  public static final String MESSAGE_ADDRESS = "greeting.message";

  @Override
  public void start() throws Exception {
    super.start();
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<String> consumer = eventBus.consumer(MESSAGE_ADDRESS);
    //list for message
    consumer.handler(message -> {
      System.out.println(HelloService.class.getName() + "  -  " + message.body());
    });
  }
}

package com.cts.vertx.microservice.eventbus;

import io.vertx.core.AbstractVerticle;

public class Deployer extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    vertx.deployVerticle(ApiGateWayService.class.getName(), ar -> {
      if (ar.succeeded()) {
        System.out.println(ApiGateWayService.class.getName() + " " + ar.result());
      } else {
        System.out.println(ApiGateWayService.class.getName() + " " + ar.cause());
      }
    });
    vertx.deployVerticle(GreeterService.class.getName(), ar -> {
      if (ar.succeeded()) {
        System.out.println(GreeterService.class.getName() + " " + ar.result());
      } else {
        System.out.println(GreeterService.class.getName() + " " + ar.cause());
      }
    });
    vertx.deployVerticle(HelloService.class.getName(), ar -> {
      if (ar.succeeded()) {
        System.out.println(HelloService.class.getName() + " " + ar.result());
      } else {
        System.out.println(HelloService.class.getName() + " " + ar.cause());
      }
    });
  }
}
...........................................................................................
				Event bus : Point to Point
...........................................................................................


    //router for sending messsage to only consume
    router.post("/api/person").handler(rc -> {
      JsonObject person = rc.getBodyAsJson();
      eventBus.send(PERSON_ADDRESS, person, new DeliveryOptions().addHeader("id", person.getString("id")));
      rc.response().setStatusCode(201).end();
    });

package com.cts.vertx.microservice.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.json.JsonObject;

public class PersonService extends AbstractVerticle {

  public static final String PERSON_ADDRESS = "person.save";

  @Override
  public void start() throws Exception {
    super.start();
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<JsonObject> consumer = eventBus.consumer(PERSON_ADDRESS);
    //list for message
    consumer.handler(message -> {
      System.out.println(message.headers().get("id"));
      System.out.println(message.body().encodePrettily());
    });
  }
}
.............................................................................................

package com.cts.vertx.microservice.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.json.JsonObject;

public class CustomerService extends AbstractVerticle {

  public static final String CUSTOMER_ADDRESS = "customer.save";

  @Override
  public void start() throws Exception {
    super.start();
    EventBus eventBus = vertx.eventBus();
    MessageConsumer<JsonObject> consumer = eventBus.consumer(CUSTOMER_ADDRESS);
    //list for message
    consumer.handler(message -> {
      System.out.println(message.headers().get("id"));
      System.out.println(message.body().encodePrettily());
      message.reply("Customer Saved Successfully");
    });
  }
}
..............................................................................................



package com.cts.vertx.microservice.eventbus;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.eventbus.DeliveryOptions;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.handler.BodyHandler;

public class ApiGateWayService extends AbstractVerticle {
  public static final String MESSAGE_ADDRESS = "greeting.message";
  public static final String PERSON_ADDRESS = "person.save";
  public static final String CUSTOMER_ADDRESS = "customer.save";

  @Override
  public void start() throws Exception {
    super.start();
    Router router = Router.router(vertx);
    router.route().handler(BodyHandler.create());

    EventBus eventBus = vertx.eventBus();
    router.get("/api/greeter/:message").handler(rc -> {
      //Send to to event Bus
      String message = rc.request().getParam("message");
      //one to many : pub sub pattern
      eventBus.publish(MESSAGE_ADDRESS, message);
      rc.response().end("Message has been sent");
    });

    //router for sending messsage to only consumer
    router.post("/api/person").handler(rc -> {
      JsonObject person = rc.getBodyAsJson();
      eventBus.send(PERSON_ADDRESS, person, new DeliveryOptions().addHeader("id", person.getString("id")));
      rc.response().setStatusCode(201).end();
    });

    //sending message to only one consumer and get ack.
    router.post("/api/customer").handler(rc -> {
      JsonObject customer = rc.getBodyAsJson();
      eventBus.request(CUSTOMER_ADDRESS, customer, new DeliveryOptions().addHeader("id", customer.getString("id")), ar -> {
        String ack = ar.result().body().toString();
        rc.response().setStatusCode(201).end(ack);
      });
    });

    vertx.createHttpServer().requestHandler(router).listen(3000, ar -> {
      System.out.println("Server is Running @ " + ar.result().actualPort());
    });

  }
}
..............................................................................................
			Event Bus,Web,Jdbc integration : Task todo
............................................................................................

Lab: 1.Write all rest related apis in web layer, send data to database layer...via event bus.

.............................................................................................
                          Blocking code and Non blocking Code:
..............................................................................................

Vertx has been designed to work with nonblocking.
 non blocking web apps,database,tcp,file system..............

Does vertx support blocking code and what if i write blocking code ?

Yes! blocking code, what if i write blocking inside verticles.

Use case : 

You are building vertx application, vertx application need to talk to hibernate/jpa layer.
Vertx is non blocking but hibernate blocking.

if you write blocking inside non blocking vertx will throw error, but how to bridge blocking with non-blocking.
	

Blocking code

-Thread.sleep
-long running task
-legacy file io
-legacy network 
-database 
-external api


 Any blocking code can't be executed inside event loop thread.
 Any blocking code must be executed in a separte threads - Worker pool threads.
 Worker pool threads are used for running long running blocking code.

There are many ways.

how to process blocking code

1.Change the verticle thread from event loop thread to worker pool thread
  These verticle are called worker verticles
2.via an blocking apis provided by vertx.


Event Loop Thread and verticles

Every Verticle is bound with "Event loop thread" by default.

package com.cts.vertx.microservice.blocking;

import io.vertx.core.Vertx;

public class MainVertical {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
     for (int i = 1; i <=26; i++) {
      vertx.deployVerticle(new NonBlockingVertical());
    }
  }
}
..............................................................................................

Threading Blocking timeout:

Generally we should not block the event loop thread for long time.
How long? 2000ms - default blocking timeout.
if the code blocks beyond 2000ms, 

-it will give warining
-if it beyond warining, it will throw execption.


package com.cts.vertx.microservice.blocking;

import io.vertx.core.Vertx;

public class BlockTheVertilcle {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new BlockingVerticle());
  }
}

package com.cts.vertx.microservice.blocking;

import io.vertx.core.AbstractVerticle;

public class BlockingVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(Thread.currentThread().getName());
    Thread.sleep(10000);
    System.out.println("Sleep over");
  }
}

Aug 27, 2021 4:48:45 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 2612 ms, time limit is 2000 ms
Aug 27, 2021 4:48:46 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 3612 ms, time limit is 2000 ms
Aug 27, 2021 4:48:47 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 4613 ms, time limit is 2000 ms
Aug 27, 2021 4:48:48 PM io.vertx.core.impl.BlockedThreadChecker
WARNING: Thread Thread[vert.x-eventloop-thread-0,5,main] has been blocked for 5614 ms, time limit is 2000 ms
io.vertx.core.VertxException: Thread blocked
	at java.base@11.0.11/java.lang.Thread.sleep(Native Method)
	at app//com.cts.vertx.microservice.blocking.BlockingVerticle.start(BlockingVerticle.java:10)
	at app//io.vertx.core.AbstractVerticle.start(AbstractVerticle.java:106)
	at app//io.vertx.core.impl.DeploymentManager.lambda$doDeploy$5(DeploymentManager.java:196)
	at app//io.vertx.core.impl.DeploymentManager$$Lambda$77/0x0000000800178840.handle(Unknown Source)
	at app//io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:96)
	at app//io.vertx.core.impl.AbstractContext.dispatch(AbstractContext.java:59)
	at app//io.vertx.core.impl.EventLoopContext.lambda$runOnContext$0(EventLoopContext.java:37)
	at app//io.vertx.core.impl.EventLoopContext$$Lambda$78/0x0000000800179440.run(Unknown Source)
	at app//io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:164)
	at app//io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:472)
	at app//io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:500)
	at app//io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)
	at app//io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at app//io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base@11.0.11/java.lang.Thread.run(Thread.java:834)

..........................................................................................
	What if i want to write blocking code , i need to handle smothly
.........................................................................................



Types of Verticle:

1.standard Verticle
   Verticles are normal , executed by event loop thread
2.Woker verticles
   Verticles are special,executed by a separate thread of execution called "Worker poll threads".


package com.cts.vertx.microservice.blocking;

import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;

public class WorkerVerticalDeployer {
  public static void main(String[] args) {
    //convert normal vertical into worker vertical
    Vertx vertx = Vertx.vertx();
    //How to configure Verticle : Verticle configuration
    //control verticle configurations
    DeploymentOptions options = new DeploymentOptions().setWorker(true);
    vertx.deployVerticle(new WorkerVerticle(), options);
   // vertx.deployVerticle(new WorkerVerticle());


  }
}
..............................................................................................

package com.cts.vertx.microservice.blocking;

import io.vertx.core.AbstractVerticle;

public class WorkerVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    System.out.println(Thread.currentThread().getName());
    //work verticle , we can write blocking code
    Thread.sleep(10000);
    vertx.createHttpServer().requestHandler(ar -> {
      System.out.println("Inside Http Server" + Thread.currentThread().getName());
      ar.response().end("hello");
    }).listen(8080);
    System.out.println("Hello");
  }
}
.............................................................................................
	    How to write blocking code and non blocking in the same verticle
.............................................................................................

Incase i have 2 methods are blocking methods and 3 methods are non blocking methods in a single verticle?


2 methods must be handled by work pool threads
3 methods must be handled by event loop threads.

vertx.executeBlocking(blockingcode,grabblocking result);

package com.cts.vertx.microservice.blocking;

import io.vertx.core.AbstractVerticle;
import io.vertx.ext.web.Router;

public class ExecuteBlockingVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    vertx.executeBlocking(blockingHandler -> {
      //blocking code will go here
      System.out.println("start blocking" + Thread.currentThread().getName());
      try {
        Thread.sleep(10000);
        //send data to result handler
        blockingHandler.complete("This is blocking api response");
      } catch (InterruptedException e) {
        blockingHandler.fail("Someting went wrong");
      }

    }, resultHandler -> {
      System.out.println("Got Result from the  blocking Handler " + Thread.currentThread().getName());
      if (resultHandler.succeeded()) {
        System.out.println(resultHandler.result());
      }
    });

    Router router = Router.router(vertx);

    router.get("/nonblocking").handler(rc -> rc.response().end("non blocking"));

    router.get("/blocking").blockingHandler(rc -> {
      try {
        //call blocking api from this end
        //here you can call hibernate api call
        Thread.sleep(10000);
        rc.response().end("Hello,I am blocking Response");
      } catch (Exception es) {

      }
    });

    vertx.createHttpServer().requestHandler(router).listen(8080);

  }
}
...........................................................................................
				Distributed Configuration
..........................................................................................
Vertx Configuration :Distributed Configuration:
.........................

How to configure Vertx application:

Vert.x Config
  This component provides an extensible way to configure Vert.x applications.


Configuration Stores(Storage):
..............................

Physical storage:

1.files
2.directories -ldap....
3.HTTP Servers - a separate HTTP server.
4.Redis
5.System Properties
6.environment properties
7.In memory Store: Application memory

Configuration representation inisde vertx is json object.

Storage file formats:
1.yaml
2.json
3.properties
......

Verticle:
 -can read config  data from the Vertx Context Object / DeploymentOptions
 -can read config data  from the file via command line args
 -can read from any storage via Vertx-Config module objects like ConfigReteriver.


Use Case 1 :Application inmememory configuration.

How to supply configuration info to Verticle?


 -can read config  data from the Vertx Context Object
     via DeploymentOptions we need to inject config data.

-via DeploymentOptions while verticle is being deployed.

-How to read configuration which was supplied via DeploymentOptions

AbstractVerticle has an api 

public JsonObject config()
Get the configuration of the verticle.
This can be specified when the verticle is deployed.

Returns:
the configuration


Steps:

1.create DeploymentOptions Object

JsonObject config=new JsonObject().put("message","Hello");

DeploymentOptions  options=new DeploymentOptions();

options.setConfig(config);

vertx.deployVerticle(Verticle,options)


package com.cts.vertx.microservice.config;

import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;

public class ConfigDeployer {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    DeploymentOptions options = new DeploymentOptions()
      .setWorker(false)
      .setConfig(new JsonObject().put("message", "Hello"));
    vertx.deployVerticle(new ApplicationConfigVerticle(), options);

  }
}

package com.cts.vertx.microservice.config;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.json.JsonObject;

public class ApplicationConfigVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    JsonObject myConfig = config();
    System.out.println(myConfig.encodePrettily());
  }
}
.........................................................................................
Merging many configuration into one.

package com.cts.vertx.microservice.config;

import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.json.JsonObject;

public class ConfigDeployer {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();

    JsonObject serverConfig = new JsonObject()
      .put("http.port", 3000)
      .put("http.host", "locahost")
      .put("http.ssl", false);


    JsonObject applicationConfig = new JsonObject()
      .put("name", "Subramanian")
      .put("city", "Coimbatore")
      .put("state", "TN")
      .put("message", "Hello")
      .mergeIn(serverConfig);

    DeploymentOptions options = new DeploymentOptions()
      .setWorker(false)
      .setConfig(applicationConfig);
    vertx.deployVerticle(new ApplicationConfigVerticle(), options);

  }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
Vert can read from Operating system env variables and system properties
System.out.println(System.getProperty("java.home"));
System.out.println(System.getProperty("path.separator"));
System.out.println(System.getenv("path"));


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


How to read configuration from external configuration system.
 
Configuration system could be file,dir,git......


1.ConfigRetriever:

  It configures a set of configuration store, where Configuration store defines  a location 
  from where the configuration data is read and also format(JSON by default).

 The Result from ConfigRetriever is JSON object.

Flow

  Application ------------------|ConfigRetriver----|ConfigStore
				JSON Object	<----	


How to instantiate the ConfigRetriver:

 ConfigRetriver retriver = ConfigRetriver.create(vertx);


Reading from json file:

Note: ConfigRetiver uses by default json file. if you read other than json  you need to extra depedencies.

Steps:

1.Add Dependency.

<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-config</artifactId>
 <version>3.9.2</version>
</dependency>

2.create resources/config/config.json file

{
  "appname": "IBM Vertx Application",
  "version": "1.0.0"
}

3.set storage options
   ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));

4.Create ConfigReteriver

    ConfigRetriever retriever = ConfigRetriever.create(vertx, new ConfigRetrieverOptions().addStore(options));

    retriever.getConfig(config -> {
      if (config.succeeded()) {
        System.out.println("Config is Ready");
        //System.out.println(config.result());
        JsonObject configRes = config.result();
        System.out.println(configRes.getString("appname"));
        System.out.println(configRes.getString("version"));

      } else {
        System.out.println("Config Error : " + config.cause());
      }
    });


class ExternalConfigVerticle extends AbstractVerticle{
  @Override
  public void start() throws Exception {
    super.start();
    //store options
    ConfigStoreOptions options = new ConfigStoreOptions();
    options.setType("file");
    options.setFormat("json");
    options.setConfig(new JsonObject().put("path", "conf/config.json"));

    //config reteriver
    ConfigRetriever retriever = ConfigRetriever.create(vertx, new ConfigRetrieverOptions().addStore(options));
    //read configuration
    retriever.getConfig(config -> {
      if (config.succeeded()) {
        System.out.println("Config is Ready");
        //System.out.println(config.result());
        JsonObject configRes = config.result();
        System.out.println(configRes.getString("appname"));
        System.out.println(configRes.getString("version"));

      } else {
        System.out.println("Config Error : " + config.cause());
      }
    });

  }
}
...........................................................................................
					Yaml Configuration
.............................................................................................


<dependency>
 <groupId>io.vertx</groupId>
 <artifactId>vertx-config-yaml</artifactId>
 <version>3.9.2</version>
</dependency>


ConfigStoreOptions store = new ConfigStoreOptions()
  .setType("file")
  .setFormat("yaml")
  .setConfig(new JsonObject()
    .put("path", "my-config.yaml")
  );

ConfigRetriever retriever = ConfigRetriever.create(vertx,
    new ConfigRetrieverOptions().addStore(store));
..............................................................................................
				System Properties
............................................................................................

You can supply config parameters to the verticle during deployment.

java -Dserver.host=localhost -Dserver.port=8080   -jar   target/application.jar


package com.cts.config;

import io.vertx.config.ConfigRetriever;
import io.vertx.config.ConfigRetrieverOptions;
import io.vertx.config.ConfigStoreOptions;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.json.JsonObject;

public class MainVerticle extends AbstractVerticle {

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    ConfigStoreOptions sys = new ConfigStoreOptions()
      .setType("sys")
      .setConfig(new JsonObject().put("hierarchical", true));
    ConfigRetriever retriever = ConfigRetriever.create(vertx, new ConfigRetrieverOptions().addStore(sys));

    //read configuration
    retriever.getConfig(config -> {
      if (config.succeeded()) {
        System.out.println("Config is Ready");
        //System.out.println(config.result());
        JsonObject configRes = config.result();
        // System.out.println(configRes.encodePrettily());
        System.out.println(" port : " + configRes.getString("server.port","8080"));
      } else {
        System.out.println("Config Error : " + config.cause());
      }
    });
    vertx.createHttpServer().requestHandler(req -> {
      req.response()
        .putHeader("content-type", "text/plain")
        .end("Hello from Vert.x!");
    }).listen(8888, http -> {
      if (http.succeeded()) {
        startPromise.complete();
        System.out.println("HTTP server started on port 8888");
      } else {
        startPromise.fail(http.cause());
      }
    });
  }
}
..............................................................................................
			How to integrate Reactive Extension Vertx
..............................................................................................

Vertx offers abstraction on Rxjava2 ,This process is called "Rxfication".
 -We have less api , to get start writing reactive code using vertx.

Styles of vertx code

1.callback style 
2.reactive style


Reactive Verticle and deploy them

package com.cts.reactive;

import io.vertx.reactivex.core.AbstractVerticle;

public class HelloWorldReactiveVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
  }
}

package com.cts.reactive;

import io.vertx.reactivex.core.Vertx;

public class ReactiveDeployer {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.rxDeployVerticle(new HelloWorldReactiveVerticle()).subscribe(result -> {
        System.out.println(result);
      }, err -> {
        System.out.println(err);
      }
    );
  }
}
.............................................................................................
					Reactive Http Server
..........................................................................................

package com.cts.reactive;

import io.vertx.reactivex.core.AbstractVerticle;
import io.vertx.reactivex.core.http.HttpServer;

public class HelloWorldReactiveVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    //reactive http server
    HttpServer httpServer = vertx.createHttpServer();

    //handling request
    httpServer.requestStream().toFlowable().subscribe(request -> {

      //      HttpServerResponse response = request.response();
//      //enables streaming of data
//      response.setChunked(true);
////      request.toFlowable().subscribe(
////        onNext -> {
////          response.write("Hello Reactive");
////        },
////        onError -> {
////          System.out.println("err");
////        },
////        () -> {
////          response.end();
////        }
////      );

//      request.toFlowable().subscribe(
//        onNext -> {
//          response.write("Hello Reactive");
//        },
//        onError -> {
//          System.out.println("err");
//        },
//        () -> {
//          response.end();
//        }
//      );
//      request.response()
//        .setChunked(true);
      request.toFlowable().subscribe(
        onNext -> {
          // response.write("Hello Reactive");
          request.response()
            .setChunked(true).write("Hello Reactive!!!!");
        },
        System.out::println,
        () -> {
          request.response()
            .end();
        }
      );

    });

    httpServer.rxListen(3000).subscribe(httpServer1 -> {
      System.out.println("Reactive Server is running" + httpServer1.actualPort());
    }, err -> {
      System.out.println("Server startup faild");
    });
  }
}
.............................................................................................


package com.cts.reactive;

import io.vertx.core.json.JsonObject;
import io.vertx.reactivex.core.AbstractVerticle;
import io.vertx.reactivex.ext.jdbc.JDBCClient;

public class ReactiveDatabase extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    String url = "jdbc:hsqldb:mem:test?shutdown=true";
    String driver = "org.hsqldb.jdbcDriver";
    String CRATE_TABLE = "CREATE TABLE IF NOT EXISTS products(id int IDENTITY, name VARCHAR(255), price FLOAT, weight INT)";
    String INSERT_TABLE = "INSERT INTO products (name,price,weight) VALUES('phone',10000,100)";
    String SELECT = "SELECT * From products";
    JsonObject jsonObject = new JsonObject().put("url", url).put("driver_class", driver);
    JDBCClient jdbcClient = JDBCClient.createShared(vertx, jsonObject);

    System.out.println("Reactive Database connection starts");
    jdbcClient.rxGetConnection().flatMapObservable(conn -> {
      System.out.println("connection");
      //chaining : create table,insert row,select rows
      //return should return Observable Type-Flowable/Observable
      return conn.rxUpdate(CRATE_TABLE).flatMap(insertResult -> {
        System.out.println("INSERT TABLE OPERATION BEGINS");
        return conn.rxUpdate(INSERT_TABLE);
      }).flatMap(updateResult -> {
        System.out.println("SELECT TABLE OPERATION BEGINS");
        return conn.rxQueryStream(SELECT);
      }).toObservable();
    }).subscribe(
      row -> {
        System.out.println(row.toFlowable().subscribe(System.out::println));
      }
    );

  }
}
.............................................................................................
				Event Bus and Reactive
.............................................................................................
package com.cts.reactive;

import io.vertx.reactivex.core.AbstractVerticle;
import io.vertx.reactivex.core.eventbus.EventBus;

public class ReactiveEventBus extends AbstractVerticle {

  String ADDRESS = "greeting.message";

  @Override
  public void start() throws Exception {
    super.start();
    EventBus eventBus = vertx.eventBus();

    //consumer
    eventBus.consumer(ADDRESS).toFlowable().subscribe(message -> {
      System.out.println("Received : " + message.body());
      message.reply("PONG");
    });

    //publish message using timer

    vertx.setTimer(5000, v -> {
      eventBus.rxRequest(ADDRESS, "PING").subscribe(
        message -> {
          System.out.println(message.body());
        }
      );
    });

  }
}
package com.cts.reactive;

import io.vertx.reactivex.core.Vertx;

public class EventBusDeployer {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.rxDeployVerticle(new ReactiveEventBus()).subscribe(System.out::println, System.out::println);
  }
}
.............................................................................................

package com.cts.reactive;

import io.reactivex.Single;
import io.vertx.reactivex.core.AbstractVerticle;
import io.vertx.reactivex.core.http.HttpServer;
import io.vertx.reactivex.ext.web.client.HttpResponse;
import io.vertx.reactivex.ext.web.client.WebClient;
import io.vertx.reactivex.ext.web.codec.BodyCodec;

public class WebClientReactive extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    WebClient webClient = WebClient.create(vertx);

    HttpServer httpServer = vertx.createHttpServer();
    httpServer.requestStream().toFlowable().subscribe(req -> {
      //Reactive is lazy
      Single<HttpResponse<String>> request = webClient
        .get(3000, "localhost", "/").as(BodyCodec.string()).rxSend();
      //until subscribe method is called , which never calls api
      request.subscribe(res -> {
        System.out.println("Server response " + res.body() + " " + res.statusCode());
         req.response().end("Hello!How are you");
      });
    });
    httpServer.rxListen(3001).subscribe(onSuccess -> {
      System.out.println("Client is Running on " + onSuccess.actualPort());
    });

  }
}

package com.cts.reactive;

import io.vertx.reactivex.core.AbstractVerticle;
import io.vertx.reactivex.core.http.HttpServer;

public class WebClientServer extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();

    HttpServer httpServer = vertx.createHttpServer();
    httpServer.requestStream().toFlowable().subscribe(req -> {
      System.out.println("Request has come");
      req.response().end("Hello!How are you");
    });
    httpServer.rxListen(3000).subscribe(onSuccess -> {
      System.out.println("Server is Running on " + onSuccess.actualPort());
    });
  }
}
package com.cts.reactive;

import io.vertx.reactivex.core.Vertx;

public class WebClientReactiveDeployer {
  public static void main(String[] args) {
    Vertx vertx =Vertx.vertx();
    vertx.rxDeployVerticle(new WebClientServer()).subscribe();
    vertx.rxDeployVerticle(new WebClientReactive()).subscribe();

  }
}
..............................................................................................
			Scalability : How to run multiple instance of the same service
.............................................................................................

package com.cts.vertx_scalling;

import io.vertx.reactivex.core.AbstractVerticle;
import io.vertx.reactivex.core.http.HttpServer;

public class GreeterService extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();

    HttpServer httpServer = vertx.createHttpServer();
    httpServer.requestStream().toFlowable().subscribe(req -> {
      req.response().end("Hello!How are you : " + Thread.currentThread().getName() + " " + hashCode());
    });
    httpServer.rxListen(3000).subscribe(onSuccess -> {
      System.out.println("Server is Running on " + onSuccess.actualPort());
    });
  }
}

package com.cts.vertx_scalling;

import io.vertx.reactivex.core.AbstractVerticle;
import io.vertx.reactivex.core.http.HttpServer;

public class GreeterService extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();

    HttpServer httpServer = vertx.createHttpServer();
    httpServer.requestStream().toFlowable().subscribe(req -> {
      req.response().end("Hello!How are you : " + Thread.currentThread().getName() + " " + hashCode());
    });
    httpServer.rxListen(3000).subscribe(onSuccess -> {
      System.out.println("Server is Running on " + onSuccess.actualPort());
    });
  }
}

package com.cts.vertx_scalling;

import io.vertx.core.DeploymentOptions;
import io.vertx.reactivex.core.Vertx;

public class ScallerDeployer {
  //mai
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    DeploymentOptions options = new DeploymentOptions().setInstances(3);

    vertx.rxDeployVerticle(GreeterService.class.getName(), options).subscribe(res -> {
      System.out.println(GreeterService.class.getName() + " " + res);
    }, err -> {
      System.out.println(err);
    });

    vertx.rxDeployVerticle(ApiGateWayService.class.getName(), options).subscribe(res -> {
      System.out.println(ApiGateWayService.class.getName() + " " + res);
    }, err -> {
      System.out.println(err);
    });
  }
}
............................................................................................
			Clustering : How to communicate across vertx Engine
			         (Scallablity + High availablity)
............................................................................................

Distributed Vertx:
.................

As of now we have seen 
 -How to write verticle on single vertx engine
 -How verticles communicate using event bus on single vertx engine


Multi node architecture: Multi vertx engine architecuture:

Vertx Types:
...........

1.Standard Vertx
   -single vertx engine
2.Clustered Vertx
   -distributed vertx engine.

Clustering:

 Grouping  multiple different vertx engines  under one single communication system.
Kind of networking.we are making networking infrastructure among Vertx engins.

How many vertx engines can communcates?

 more vertx engines

Via Cluster Managers and Providers :

 Cluster Providers are third party servers, through vertx can communicates.

Vertx - Clustering:
...................

Clustering , means organization application under one communication channel.

Vertx uses integration/clustering technologies.

Vertx uses hazelcast ClusterManager/provider by default.

Cluster : group of something - group of verticles/vertx instance/jvm

in order to connect vertx apps across processes, we need cordinator 
-Bride softwares

Vertx can work with
-hazelcast
-apache zookeeper
-apache ignite
-apache Infinispan

dependency:

vertx-hazelcast

ClusterManagers

by default, vertx has hazelcast, we dont need to configure by default.


ClusterManagers

by default, vertx has hazelcast, we dont need to configure by default.


How to enable clustering?

In vertx clustering can be enabled in two ways

1.through code

Vertx Configuration;

Types of vertx:
1.standard vertx
2.clusteredVertx

ClusterManager mgr = new HazelcastClusterManager();

VertxOptions options = new VertxOptions().setClusterManager(mgr);

Vertx.clusteredVertx(options, res -> {
  if (res.succeeded()) {
    Vertx vertx = res.result();
  } else {
    // failed!
  }
});

Configuring cluster manager:

Vertx provides default-cluster.xml which is packaged inside cluster jar.

if you want to override you can override cluster.xml file

How to enable cluster feature?

java -jar target/app.jar -cp . -cluster

vertx run verticle -cp . -cluster
..............................................................................................
				
1.Clustering
   
   We can run multiple vertx applications and each application can communicate each other 
via centeralized cluter channel software(hazelcast,zookeeper,apache ignite).

in order to setup cluster on vertx engine
1.we have to enable via Vertx.clusteredVertx Method.


Demo setup:
we are simulating two verticles running separtely. how we can do that

-need to run two verticles having main method.

Two verticles are exchanging message via event bus (Distributed Event Bus).

eg:

1.ConsumerVerticle

package com.cts.vertx.cluster;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class ConsumerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions().setClusterManager(mgr).setHAEnabled(true).setHAGroup("g1");
    Vertx.clusteredVertx(options, cluster -> {
      if (cluster.succeeded()) {
        DeploymentOptions deploymentOptions = new DeploymentOptions();
        cluster.result().deployVerticle("com.cts.vertx.cluster.ConsumerVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });
      } else {
        System.out.println("Cluster up failed: " + cluster.cause());
      }
    });
  }

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
      String jvmName = runtimeBean.getName();
      System.out.println("Node  Name = " + jvmName);
      long pid = Long.valueOf(jvmName.split("@")[0]);
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      System.out.println("News 7's Today News : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}


2.Producer Verticle

package com.cts.vertx.cluster;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class PublisherVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions().setClusterManager(mgr).setHAEnabled(true).setHAGroup("g1");

    Vertx.clusteredVertx(options, vertxAsyncResult -> {
      if (vertxAsyncResult.succeeded()) {
        //deploy verticles on cluster env.
        DeploymentOptions deploymentOptions = new DeploymentOptions()
          .setInstances(2).setHa(true);
        vertxAsyncResult.result().deployVerticle("com.cts.vertx.cluster.PublisherVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });

      } else {
        System.out.println("Cluster up failed: " + vertxAsyncResult.cause());
      }
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
    String jvmName = runtimeBean.getName();
    //processid
    long pid = Long.valueOf(jvmName.split("@")[0]);
    vertx.setPeriodic(5000, ar -> {
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      //publish message
      String news = "Last 24 hrs, 50000 covid patients in India" + " From  " + jvmName;
      vertx.eventBus().publish("news.in.covid", news);
    });

  }
}


Run two programs  one by one.

Consumer:
Sep 01, 2021 3:55:37 PM com.hazelcast.instance.impl.HazelcastInstanceFactory
WARNING: Hazelcast is starting in a Java modular environment (Java 9 and newer) but without proper access to required Java packages. Use additional Java arguments to provide Hazelcast access to Java internal API. The internal API access is used to get the best performance results. Arguments to be used:
 --add-modules java.se --add-exports java.base/jdk.internal.ref=ALL-UNNAMED --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/java.nio=ALL-UNNAMED --add-opens java.base/sun.nio.ch=ALL-UNNAMED --add-opens java.management/sun.management=ALL-UNNAMED --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED
Sep 01, 2021 3:55:37 PM com.hazelcast.instance.AddressPicker
INFO: [LOCAL] [dev] [4.0.2] Prefer IPv4 stack is true, prefer IPv6 addresses is false
Sep 01, 2021 3:55:37 PM com.hazelcast.instance.AddressPicker
INFO: [LOCAL] [dev] [4.0.2] Picked [192.168.0.101]:5701, using socket ServerSocket[addr=/0:0:0:0:0:0:0:0,localport=5701], bind any local is true
Sep 01, 2021 3:55:37 PM com.hazelcast.system
INFO: [192.168.0.101]:5701 [dev] [4.0.2] Hazelcast 4.0.2 (20200702 - 2de3027) starting at [192.168.0.101]:5701
Sep 01, 2021 3:55:37 PM com.hazelcast.system
INFO: [192.168.0.101]:5701 [dev] [4.0.2] Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.
Sep 01, 2021 3:55:37 PM com.hazelcast.spi.impl.operationservice.impl.BackpressureRegulator
INFO: [192.168.0.101]:5701 [dev] [4.0.2] Backpressure is disabled
Sep 01, 2021 3:55:38 PM com.hazelcast.instance.impl.Node
INFO: [192.168.0.101]:5701 [dev] [4.0.2] Creating MulticastJoiner
Sep 01, 2021 3:55:38 PM com.hazelcast.cp.CPSubsystem
WARNING: [192.168.0.101]:5701 [dev] [4.0.2] CP Subsystem is not enabled. CP data structures will operate in UNSAFE mode! Please note that UNSAFE mode will not provide strong consistency guarantees.
Sep 01, 2021 3:55:38 PM com.hazelcast.spi.impl.operationexecutor.impl.OperationExecutorImpl
INFO: [192.168.0.101]:5701 [dev] [4.0.2] Starting 12 partition threads and 7 generic threads (1 dedicated for priority tasks)
Sep 01, 2021 3:55:38 PM com.hazelcast.internal.diagnostics.Diagnostics
INFO: [192.168.0.101]:5701 [dev] [4.0.2] Diagnostics disabled. To enable add -Dhazelcast.diagnostics.enabled=true to the JVM arguments.
Sep 01, 2021 3:55:38 PM com.hazelcast.core.LifecycleService
INFO: [192.168.0.101]:5701 [dev] [4.0.2] [192.168.0.101]:5701 is STARTING
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.hazelcast.internal.networking.nio.SelectorOptimizer (file:/C:/Users/sasub/.m2/repository/com/hazelcast/hazelcast/4.0.2/hazelcast-4.0.2.jar) to field sun.nio.ch.SelectorImpl.selectedKeys
WARNING: Please consider reporting this to the maintainers of com.hazelcast.internal.networking.nio.SelectorOptimizer
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
Sep 01, 2021 3:55:40 PM com.hazelcast.internal.cluster.ClusterService
INFO: [192.168.0.101]:5701 [dev] [4.0.2] 

Members {size:1, ver:1} [
	Member [192.168.0.101]:5701 - fc2f2060-7e5f-4a68-a9ce-f5d5073fbc6f this
]

Sep 01, 2021 3:55:40 PM com.hazelcast.core.LifecycleService
INFO: [192.168.0.101]:5701 [dev] [4.0.2] [192.168.0.101]:5701 is STARTED
Sep 01, 2021 3:55:40 PM com.hazelcast.internal.partition.impl.PartitionStateManager
INFO: [192.168.0.101]:5701 [dev] [4.0.2] Initializing cluster partition table arrangement...
Sep 01, 2021 3:55:41 PM io.vertx.core.impl.HAManager
INFO: A quorum has been obtained. Any deploymentIDs waiting on a quorum will now be deployed
Deployment id is: 2250aa87-83d1-482b-a0ed-086c8910d5e5



After this run Producer
"C:\Program Files\Java\jdk-11.0.11\bin\java.exe" "-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2020.1.1\lib\idea_rt.jar=49876:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2020.1.1\bin" -Dfile.encoding=UTF-8 -classpath C:\session\CTS\VERTX-Session\aug\vertx-scalling\target\classes;C:\Users\sasub\.m2\repository\io\vertx\vertx-config\4.1.3\vertx-config-4.1.3.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-core\4.1.3\vertx-core-4.1.3.jar;C:\Users\sasub\.m2\repository\io\netty\netty-common\4.1.67.Final\netty-common-4.1.67.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-buffer\4.1.67.Final\netty-buffer-4.1.67.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-transport\4.1.67.Final\netty-transport-4.1.67.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-handler\4.1.67.Final\netty-handler-4.1.67.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-codec\4.1.67.Final\netty-codec-4.1.67.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-handler-proxy\4.1.67.Final\netty-handler-proxy-4.1.67.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-codec-socks\4.1.67.Final\netty-codec-socks-4.1.67.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-codec-http\4.1.67.Final\netty-codec-http-4.1.67.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-codec-http2\4.1.67.Final\netty-codec-http2-4.1.67.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-resolver\4.1.67.Final\netty-resolver-4.1.67.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-resolver-dns\4.1.67.Final\netty-resolver-dns-4.1.67.Final.jar;C:\Users\sasub\.m2\repository\io\netty\netty-codec-dns\4.1.67.Final\netty-codec-dns-4.1.67.Final.jar;C:\Users\sasub\.m2\repository\com\fasterxml\jackson\core\jackson-core\2.11.4\jackson-core-2.11.4.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-hazelcast\4.1.3\vertx-hazelcast-4.1.3.jar;C:\Users\sasub\.m2\repository\com\hazelcast\hazelcast\4.0.2\hazelcast-4.0.2.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-web-client\4.1.3\vertx-web-client-4.1.3.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-web-common\4.1.3\vertx-web-common-4.1.3.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-auth-common\4.1.3\vertx-auth-common-4.1.3.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-rx-java2\4.1.3\vertx-rx-java2-4.1.3.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-rx-java2-gen\4.1.3\vertx-rx-java2-gen-4.1.3.jar;C:\Users\sasub\.m2\repository\io\reactivex\rxjava2\rxjava\2.2.21\rxjava-2.2.21.jar;C:\Users\sasub\.m2\repository\org\reactivestreams\reactive-streams\1.0.3\reactive-streams-1.0.3.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-rx-gen\4.1.3\vertx-rx-gen-4.1.3.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-codegen\4.1.3\vertx-codegen-4.1.3.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-web\4.1.3\vertx-web-4.1.3.jar;C:\Users\sasub\.m2\repository\io\vertx\vertx-bridge-common\4.1.3\vertx-bridge-common-4.1.3.jar com.cts.vertx.cluster.PublisherVerticle
Sep 01, 2021 3:56:09 PM com.hazelcast.instance.impl.HazelcastInstanceFactory
WARNING: Hazelcast is starting in a Java modular environment (Java 9 and newer) but without proper access to required Java packages. Use additional Java arguments to provide Hazelcast access to Java internal API. The internal API access is used to get the best performance results. Arguments to be used:
 --add-modules java.se --add-exports java.base/jdk.internal.ref=ALL-UNNAMED --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/java.nio=ALL-UNNAMED --add-opens java.base/sun.nio.ch=ALL-UNNAMED --add-opens java.management/sun.management=ALL-UNNAMED --add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED
Sep 01, 2021 3:56:09 PM com.hazelcast.instance.AddressPicker
INFO: [LOCAL] [dev] [4.0.2] Prefer IPv4 stack is true, prefer IPv6 addresses is false
Sep 01, 2021 3:56:09 PM com.hazelcast.instance.AddressPicker
INFO: [LOCAL] [dev] [4.0.2] Picked [192.168.0.101]:5702, using socket ServerSocket[addr=/0:0:0:0:0:0:0:0,localport=5702], bind any local is true
Sep 01, 2021 3:56:09 PM com.hazelcast.system
INFO: [192.168.0.101]:5702 [dev] [4.0.2] Hazelcast 4.0.2 (20200702 - 2de3027) starting at [192.168.0.101]:5702
Sep 01, 2021 3:56:09 PM com.hazelcast.system
INFO: [192.168.0.101]:5702 [dev] [4.0.2] Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.
Sep 01, 2021 3:56:10 PM com.hazelcast.spi.impl.operationservice.impl.BackpressureRegulator
INFO: [192.168.0.101]:5702 [dev] [4.0.2] Backpressure is disabled
Sep 01, 2021 3:56:10 PM com.hazelcast.instance.impl.Node
INFO: [192.168.0.101]:5702 [dev] [4.0.2] Creating MulticastJoiner
Sep 01, 2021 3:56:10 PM com.hazelcast.cp.CPSubsystem
WARNING: [192.168.0.101]:5702 [dev] [4.0.2] CP Subsystem is not enabled. CP data structures will operate in UNSAFE mode! Please note that UNSAFE mode will not provide strong consistency guarantees.
Sep 01, 2021 3:56:10 PM com.hazelcast.spi.impl.operationexecutor.impl.OperationExecutorImpl
INFO: [192.168.0.101]:5702 [dev] [4.0.2] Starting 12 partition threads and 7 generic threads (1 dedicated for priority tasks)
Sep 01, 2021 3:56:10 PM com.hazelcast.internal.diagnostics.Diagnostics
INFO: [192.168.0.101]:5702 [dev] [4.0.2] Diagnostics disabled. To enable add -Dhazelcast.diagnostics.enabled=true to the JVM arguments.
Sep 01, 2021 3:56:10 PM com.hazelcast.core.LifecycleService
INFO: [192.168.0.101]:5702 [dev] [4.0.2] [192.168.0.101]:5702 is STARTING
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.hazelcast.internal.networking.nio.SelectorOptimizer (file:/C:/Users/sasub/.m2/repository/com/hazelcast/hazelcast/4.0.2/hazelcast-4.0.2.jar) to field sun.nio.ch.SelectorImpl.selectedKeys
WARNING: Please consider reporting this to the maintainers of com.hazelcast.internal.networking.nio.SelectorOptimizer
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
Sep 01, 2021 3:56:11 PM com.hazelcast.internal.cluster.impl.MulticastJoiner
INFO: [192.168.0.101]:5702 [dev] [4.0.2] Trying to join to discovered node: [192.168.0.101]:5701
Sep 01, 2021 3:56:11 PM com.hazelcast.internal.nio.tcp.TcpIpConnector
INFO: [192.168.0.101]:5702 [dev] [4.0.2] Connecting to /192.168.0.101:5701, timeout: 10000, bind-any: true
Sep 01, 2021 3:56:11 PM com.hazelcast.internal.nio.tcp.TcpIpConnection
INFO: [192.168.0.101]:5702 [dev] [4.0.2] Initialized new cluster connection between /192.168.0.101:49946 and /192.168.0.101:5701
Sep 01, 2021 3:56:17 PM com.hazelcast.internal.cluster.ClusterService
INFO: [192.168.0.101]:5702 [dev] [4.0.2] 

Members {size:2, ver:2} [
	Member [192.168.0.101]:5701 - fc2f2060-7e5f-4a68-a9ce-f5d5073fbc6f
	Member [192.168.0.101]:5702 - db7b37ac-7a0e-4ca2-b3d9-3540d0352016 this
]

Sep 01, 2021 3:56:18 PM com.hazelcast.core.LifecycleService
INFO: [192.168.0.101]:5702 [dev] [4.0.2] [192.168.0.101]:5702 is STARTED
Sep 01, 2021 3:56:18 PM io.vertx.core.impl.HAManager
INFO: A quorum has been obtained. Any deploymentIDs waiting on a quorum will now be deployed
Deployment id is: d1a2e316-44ad-478f-a812-e72810159084
PID  = 23668 Thread = vert.x-eventloop-thread-2
PID  = 23668 Thread = vert.x-eventloop-thread-1
PID  = 23668 Thread = vert.x-eventloop-thread-2
PID  = 23668 Thread = vert.x-eventloop-thread-1
...........................................................................................
	   Now you can see the output in consumer which publishing messages
...........................................................................................
				2.Scalling

We have discussed already, how to scale no instances on vertx engine
...........................................................................................
				3.High Avaliablity and Fail-Over

When we are running vertx in cluster env, there is possiblity of vertx instances may die abruuptly.
The verticle is running in the same vertx engine, we need to move to antoher vertx engines

Rules for fail-over:
1.All vertx engine should be part of cluster
2.All vertx engines should have common "cluster-group-id"
3.Fail over is enabled by killing process only, not ctrl+c or Kill -SIGINT

How to enable fail-over?

via command line

Steps: 

Open cmd  3 command prompt

1.vertx run ConsumerVerticle.java -ha -hagroup g1
2.vertx run PublisherVerticle.java -ha -hagroup g1
3.vertx bare -hagroup g1

via code
    VertxOptions options = new VertxOptions().setClusterManager(mgr)
   .setHAEnabled(true).setHAGroup("g1");


How  to enable auto scalling(means if any one instance dies ,automatically we can redeploy into another instances).

docker run -i -t vertx/vertx4-exec bare -hagroup g1


.............................................................................................

package com.cts.vertx.cluster;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class PublisherVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions().setClusterManager(mgr).setHAEnabled(true).setHAGroup("g1");

    Vertx.clusteredVertx(options, vertxAsyncResult -> {
      if (vertxAsyncResult.succeeded()) {
        //deploy verticles on cluster env.
        DeploymentOptions deploymentOptions = new DeploymentOptions()
          .setInstances(2).setHa(true);
        vertxAsyncResult.result().deployVerticle("com.cts.vertx.cluster.PublisherVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });

      } else {
        System.out.println("Cluster up failed: " + vertxAsyncResult.cause());
      }
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
    String jvmName = runtimeBean.getName();
    //processid
    long pid = Long.valueOf(jvmName.split("@")[0]);
    vertx.setPeriodic(5000, ar -> {
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      //publish message
      String news = "Last 24 hrs, 50000 covid patients in India" + " From  " + jvmName;
      vertx.eventBus().publish("news.in.covid", news);
    });

  }
}
.............................................................................................
package com.cts.vertx.cluster;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.DeploymentOptions;
import io.vertx.core.Vertx;
import io.vertx.core.VertxOptions;
import io.vertx.core.eventbus.EventBus;
import io.vertx.core.eventbus.MessageConsumer;
import io.vertx.core.spi.cluster.ClusterManager;
import io.vertx.spi.cluster.hazelcast.HazelcastClusterManager;

import java.lang.management.ManagementFactory;
import java.lang.management.RuntimeMXBean;

public class ConsumerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    ClusterManager mgr = new HazelcastClusterManager();
    VertxOptions options = new VertxOptions().setClusterManager(mgr).setHAEnabled(true).setHAGroup("g1");
    Vertx.clusteredVertx(options, cluster -> {
      if (cluster.succeeded()) {
        DeploymentOptions deploymentOptions = new DeploymentOptions();
        cluster.result().deployVerticle("com.cts.vertx.cluster.ConsumerVerticle", deploymentOptions, res -> {
          if (res.succeeded()) {
            System.out.println("Deployment id is: " + res.result());
          } else {
            System.out.println("Deployment failed!");
          }
        });
      } else {
        System.out.println("Cluster up failed: " + cluster.cause());
      }
    });
  }

  private void consumeNews() {
    EventBus eventBus = vertx.eventBus();
    //Declare Consumer
    MessageConsumer<String> consumer = eventBus.consumer("news.in.covid");
    //handle/process the message/news
    consumer.handler(news -> {
      RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();
      String jvmName = runtimeBean.getName();
      System.out.println("Node  Name = " + jvmName);
      long pid = Long.valueOf(jvmName.split("@")[0]);
      System.out.println("PID  = " + pid + " Thread = " + Thread.currentThread().getName());
      System.out.println("News 7's Today News : " + news.body());
    });
  }

  @Override
  public void start() throws Exception {
    super.start();
    consumeNews();
  }
}

.............................................................................................
Taskkill /PID 12696 /F
.............................................................................................

Service Discovery and Registry:
..............................

Lookup server and naming server.

Data Base server which stores 'resources' :  web site address : dns server

Same concept is used in distributed programming/microservices:
-> RMI, EJB,DCOM

Why Service Registry?

 Registry is data base, used to store resources in centralized place.

The programs and applications  are located in networks , so it is difficult to locate/search resources.

Service discovery :

 The process of looking up resources, called service discovery.


Registry Server:
 It is key-value pair database, Where you can store and "lookup"  resources.

What we can store inside Registry Server in vertx?

 Resources:

Types of Resources(Services):
.............................
The services you can register into registry

HTTP Endpoint -HttpEndPoint.createRecord
Event Bus Service -EventBus.createRecord
Message Source
JDBC Data Source
Redis Data Source
MongoDb Data Source

Shared Data / Resource:

 In vertx you can store resources in centrialized place, and you share it across application.

eg: you have one jdbc connection, where you will store connection object, thats where shared data comes into picture.


Shared data architecture is "Service Discovery and Registry"


Implementation:

What you need?

1.Registry server- where you can store all shared resources(httpendpoint,jdbcconnection,eventbus...)

Vertx provides default built in Registry Server:
...............................................
-Key value data structure;
  Map- implementations.

Popular Registry Servers:
.........................
1.eureka server
2.Apache zoo keeper
3.Consule
4.Kubernetes
5.Redis
etc....

Core concepts:

1.Record - bag - inside bag you can store any resource-store that record into registry server.

Vertx Resource Storage:

Vertx resources are stored in side registry by packing resouces into a object called "Record".


Resource--->Record 

Service Discovery Objects:

1.Record
2.Service
3.ServiceDiscovery

Vertx has ServiceDiscovery Instance, which helps to publish / un publish ,and discover
services 


Publishing HTTP End Point into Registry, where other verticles can consume that.


Steps: /Flows:

We are going to fetch "WebClient" Reference from the Service Registry.

1.Server which provides data : Rest Service

package com.cts.vertx.microservice.serviceregistry;

import io.vertx.core.AbstractVerticle;

public class HelloRestService extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    vertx.createHttpServer().requestHandler(request -> {
      if (request.path().equals("/api/hello")) {
        request.response().end("<h1>Hello! I am coming via Service Discovery<h1>");
      }
    }).listen(3001);
  }
}

2.Create WebClient Resource points to the above Rest api , store into Registry server

package com.cts.vertx.microservice.serviceregistry;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.json.JsonObject;
import io.vertx.servicediscovery.Record;
import io.vertx.servicediscovery.ServiceDiscovery;
import io.vertx.servicediscovery.ServiceDiscoveryOptions;
import io.vertx.servicediscovery.types.HttpEndpoint;

public class ServicePublisherVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    //Service Discovery Options
//    ServiceDiscovery.create(vertx)
//      .registerServiceImporter(new ZookeeperServiceImporter()
//        , new JsonObject().put("connection", "127.0.0.1:2181"));
    ServiceDiscoveryOptions discoveryOptions = new ServiceDiscoveryOptions();
    //enable discovery server : apache zoo keeper
    discoveryOptions.setBackendConfiguration(new JsonObject()
      .put("connection", "127.0.0.1:2181")
      .put("ephemeral", true)
      .put("guaranteed", true)
      .put("basePath", "/services/my-backend")
    );
    ServiceDiscovery discovery = ServiceDiscovery.create(vertx, discoveryOptions);

    //Record Creation,Record type is Resource Type;storing webclient Resource into registry
    Record httpEndPointRecord = HttpEndpoint.createRecord("myrecord", "localhost", 3001, "/api/hello");

    //publish: add record into zookeeper
    discovery.publish(httpEndPointRecord, ar -> {
      if (ar.succeeded()) {
        System.out.println("Successfully published ..>>>>" + ar.result().toJson());
      } else {
        System.out.println(" Not Published " + ar.cause());
      }
    });

  }
}

3.Any Service can discover web Client Resource from the Registry server.


package com.cts.vertx.microservice.serviceregistry;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.web.client.WebClient;
import io.vertx.servicediscovery.ServiceDiscovery;
import io.vertx.servicediscovery.ServiceDiscoveryOptions;
import io.vertx.servicediscovery.types.HttpEndpoint;

public class ServiceConsumerVerticle extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
     ServiceDiscoveryOptions discoveryOptions = new ServiceDiscoveryOptions();
    //enable discovery server : apache zoo keeper
    discoveryOptions.setBackendConfiguration(new JsonObject()
      .put("connection", "127.0.0.1:2181")
      .put("ephemeral", true)
      .put("guaranteed", true)
      .put("basePath", "/services/my-backend")
    );
    ServiceDiscovery discovery = ServiceDiscovery.create(vertx, discoveryOptions);

    vertx.createHttpServer().requestHandler(req -> {
      HttpEndpoint.getWebClient(discovery, new JsonObject().put("name", "myrecord"), sar -> {
        // get web client
        WebClient webClient = sar.result();
        webClient.get("/api/hello").send(res -> {
          System.out.println("Response is ready!");
          req.response().end(res.result().bodyAsString());
        });
        req.response().endHandler(ar -> {
          //remove /release discovery record
          ServiceDiscovery.releaseServiceObject(discovery, webClient);
        });
      });


    }).listen(3000, ar -> {
      System.out.println("Service Consumer Service ");
    });


  }
}

4.Deployer
package com.cts.vertx.microservice.serviceregistry;

import io.vertx.core.Vertx;

public class ServiceDiscoveryMainVerticle {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new HelloRestService());
    vertx.deployVerticle(new ServicePublisherVerticle());
    vertx.deployVerticle(new ServiceConsumerVerticle());
  }
}


How to test:

http://localhost:3000
 
 ----...................../////////////////////////////////////////////////////////////////
				Resilence
.......................................................................................

Vert.x Provides circuit Breaker is an implementation of Circuit Breaker pattern.

It keeps tracks of number of failures and opens the circuit when a threshold is reached.
optionally fallback is given.

States CB:

1.closed
   -Application is working well
2.open
  -Application is failing
3.Half Open
  -Application is recovering from failures


if cb in open state
 What to do? or how to react for failures.

When cb can open?

 if max failures reached
 if timeout is reached
  

1.Circuit Breaker Configuration.

CircuitBreaker breaker = CircuitBreaker.create("my-circuit-breaker", vertx,
    new CircuitBreakerOptions()
        .setMaxFailures(5) // number of failure before opening the circuit
        .setTimeout(2000) // consider a failure if the operation does not succeed in time
        .setFallbackOnFailure(true) // do we call the fallback on failure
        .setResetTimeout(10000) // time spent in open state before attempting to re-try
);

// ---
// Store the circuit breaker in a field and access it as follows
// ---

breaker.execute(promise -> {
  // some code executing with the breaker
  // the code reports failures or success on the given promise.
  // if this promise is marked as failed, the breaker increased the
  // number of failures
}).onComplete(ar -> {
  // Get the operation result.
});
 


code:
package com.cts.vertx.microservice.cicuitbreaker;

import io.vertx.circuitbreaker.CircuitBreaker;
import io.vertx.circuitbreaker.CircuitBreakerOptions;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.buffer.Buffer;
import io.vertx.ext.web.client.HttpResponse;
import io.vertx.ext.web.client.WebClient;

public class CircuitBreakerPatternVerticle extends AbstractVerticle {

  @Override
  public void start() throws Exception {
    super.start();
    CircuitBreakerOptions options = new CircuitBreakerOptions();
    options.setMaxFailures(2);// no of failures will be allowed , after that , ciruit will open
    options.setTimeout(3000); // consider a failure if the operation does not succeed in time
    options.setFallbackOnFailure(true); // if any failure, should i handle fallback or not
    options.setResetTimeout(5000); // time spent in open state before attempting to retry.

    CircuitBreaker circuitBreaker = CircuitBreaker.create("my-circuit-breaker", vertx, options);

    vertx.createHttpServer().requestHandler(req -> {
      circuitBreaker.executeWithFallback(future -> {
        //risky code
        WebClient client = WebClient.create(vertx);
        client.get(3000, "localhost", "/").send(ar -> {
          // Obtain response
          HttpResponse<Buffer> response = ar.result();
          if (response.statusCode() != 200) {
            future.fail("HTTP error");
          } else {
            future.complete(response.bodyAsString());
          }
        });
      }, v -> {
        // Executed when the circuit is opened
        return "Hello, I am fallback";
      }).onComplete(ar -> {
        // Do something with the result
        if (ar.succeeded()) {
          //System.out.println(ar.result());
          req.response().end(ar.result());
        } else {
          System.out.println(ar.cause());

        }
      });
    }).listen(8080);

  }
}

package com.cts.vertx.microservice.cicuitbreaker;

import io.vertx.core.AbstractVerticle;

public class SomeService extends AbstractVerticle {
  @Override
  public void start() throws Exception {
    super.start();
    vertx.createHttpServer().requestHandler(r -> {
      vertx.setTimer(2000, ar -> {
        r.response().end("I am fine but delayed!");
      });
    }).listen(3000);
  }
}

package com.cts.vertx.microservice.cicuitbreaker;

import io.vertx.core.Vertx;

public class CBDeployer {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new SomeService());
    vertx.deployVerticle(new CircuitBreakerPatternVerticle());
  }
}


Testing :

just disable some service and test

also increase and decrease timer in both verticles and test



